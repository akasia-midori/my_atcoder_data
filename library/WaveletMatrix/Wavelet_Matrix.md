Wavelet Matrixについてのメモ
・基数ソートに対するテクニック集というイメージ(得られる知見多そう)
  
TODO:bitの累積和を取る場所を完備辞書にする(pythonだと定数倍遅くて意味なさそうな気がする)

<b>select</b>:[0, index)の範囲でvalueが何個あるかを取得する。  
引数:index, value
処理概要:索引の先頭を参照し、valueの開始位置＋num-1の位置を参照、  
valueを末尾のbitから取り出し、その時の0 or 1で分岐する.
・0の時、[その地点までの1の数]個目の位置へ遷移する。  
・1の時、[今の索引の行の0の個数]+[その地点までの1の数]個目の位置へ遷移する。  
遷移先の場所をindexに再設定し、索引の最終行まで行う。


<b>rank</b>:num個目のvalueがどのindex(開区間)にあったかを取得。(ナイーブにやるなら値をキーとした配列にindex入れてそれで取ればいい。無理にWM使う必要ないよ)  
引数:value, num  
処理概要:索引の最終行を参照し、valueの開始位置＋num-1の位置を参照、  
valueを末尾のbitから取り出し、その時の0 or 1で分岐する.
・0の時、一つ上の索引の0がindex個目の位置へ遷移する。  
・1の時、一つ上の索引の1がindex-[該当の索引の行の0の個数]個目の位置へ遷移する。  
遷移先の場所をindexに再設定し、索引の先頭の行まで行う。

<b>quantile</b>: [l, r)の中でk番目に小さい値を取得する。区間の幅がkよりも小さい時はk番目が存在しえないのでNoneを返す
引数: l(閉区間), r(開区間), k  
処理概要:作成した索引のl,r参照の中で0のbitと1のbitを集計する。
・0の数がk以上時、0へ遷移する。  
・0の数がk未満の時、1へ遷移する。この時、bitが0だった場所は遷移先よりも値が小さいのでbitが0の場所の個数分だけkから引いて新たなkとする。 


# topK: [l, r)の中で出現頻度の多い数値を上位k個取り出す、種類が足りない場合は途中で打ち切る　　
引数: l, r, k

処理概要:作成した索引のl,r参照、参照したbitが0 or 1で下の索引へそれぞれ遷移する。  
一番最後の索引に到達したときの幅がその値の個数になる。このような遷移の都合上、常に0と1のbitが存在するような区間に対しての計算量は愚直(幅の値を全て辞書に入れて優先度付きキューで取り出すとき)と同じになるので使用する際は十分に注意を払うこと。
