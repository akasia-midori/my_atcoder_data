{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"union find":{
		"prefix": "union_find",
		"body": [
			"from collections import defaultdict",
			"",
			"class UnionFind():",
			"    def __init__(self, n):",
			"        self.n = n",
			"        self.parents = [-1] * n",
			"",
			"    def find(self, x):",
			"        if self.parents[x] < 0:",
			"            return x",
			"        else:",
			"            self.parents[x] = self.find(self.parents[x])",
			"            return self.parents[x]",
			"",
			"    def union(self, x, y):",
			"        x = self.find(x)",
			"        y = self.find(y)",
			"",
			"        if x == y:",
			"            return",
			"",
			"        if self.parents[x] > self.parents[y]:",
			"            x, y = y, x",
			"",
			"        self.parents[x] += self.parents[y]",
			"        self.parents[y] = x",
			"",
			"    def size(self, x):",
			"        return -self.parents[self.find(x)]",
			"",
			"    def same(self, x, y):",
			"        return self.find(x) == self.find(y)",
			"",
			"    # 計算量 N ",
			"    def members(self, x):",
			"        root = self.find(x)",
			"        return [i for i in range(self.n) if self.find(i) == root]",
			"",
			"    def roots(self):",
			"        return [i for i, x in enumerate(self.parents) if x < 0]",
			"",
			"    def group_count(self):",
			"        return len(self.roots())",
			"",
			"    def all_group_members(self):",
			"        group_members = defaultdict(list)",
			"        for member in range(self.n):",
			"            group_members[self.find(member)].append(member)",
			"        return group_members",
			"",
			"    def __str__(self):",
			"        return ''.join(f'{r}: {m}' for r, m in self.all_group_members().items())"

		]

	},
	"syakutori": {
        "prefix": "syakutori",
        "body": [
            "# 参考 https://atcoder.jp/contests/abc210/tasks/abc210_c",
            "from collections import deque",
            "",
            "# 問題特有の変数とか",
            "from collections import defaultdict",
            "dicts = defaultdict(int)",
            "maxs = 0",
            "",
            "# テンプレート変数",
            "q = deque([])",
            "",
            "for i, a in enumerate(A):",
            "    q.append(a)  ## dequeの\"右端\"に要素を一つ追加する。",
            "    # 共通処理",
            "    dicts[a] += 1",
            "",
            "    # 条件が満たされてない間の処理",
            "    while q and not (len(q) <= K): ## notの中に満たすべき条件を書く",
            "        rm = q.popleft() ## 条件を満たさないのでdequeの\"左端\"から要素を取り除く",
            "        dicts[rm] -= 1",
            "        if dicts[rm] == 0:",
            "            del dicts[rm]",
            "",
            "    # 条件が満たされてる間の処理",
            "    maxs = max(maxs, len(dicts)) ",
        ],
        "description": ""
    },
    "NIBUTAN": {
        "prefix": "NIBUTAN",
        "body": [
            "import bisect",
            "# 今の値以上の物が何個あるか",
            "def count_greater_equal_num(temp, num):",
            "    index = bisect.bisect_left(temp, num)",
            "    return len(temp) - index",
            "",
            "# 今の値より上の物が何個あるか",
            "def count_greater_num(temp, num):",
            "    index = bisect.bisect_left(temp, num+1)",
            "    return len(temp) - index",
            "",
            "# 今の値以下の物が何個あるか",
            "def count_smaller_equal_num(temp, num):",
            "    return bisect.bisect_left(temp, num+1)",
            "",
            "# 今の値より下の物が何個あるか",
            "def count_smaller_num(temp, num):",
            "    return bisect.bisect_left(temp, num)",
            "",
            "",
            "",
            "def is_ok(arg):",
            "    # 条件を満たすかどうか？問題ごとに定義",
            "    # 初めてFalseからTrueになるTrueの地点を取得",
            "    pass",
            "",
            "",
            "def meguru_bisect(ng, ok):",
            "    '''",
            "    初期値のng,okを受け取り,is_okを満たす最小(最大)のokを返す",
            "    まずis_okを定義すべし",
            "    ng ok は  とり得る最小の値-1 とり得る最大の値+1",
            "    最大最小が逆の場合はよしなにひっくり返す",
            "    '''",
            "    while (abs(ok - ng) > 1):",
            "        mid = (ok + ng) // 2",
            "        if is_ok(mid):",
            "            ok = mid",
            "        else:",
            "            ng = mid",
            "    return ok",
        ],
        "description": ""
    },
    "sanbun": {
        "prefix": "sanbun",
        "body": [
            "def tri_cal(mid):",
            "    # ここで求めたい関数の値を計算する",
            "    # midは引数",
            "    ans = 0",
            "    return -1 * (mid**2) + 1",
            "",
            "def tri_search(start, end, data):",
            "    ",
            "    # 10^18でも148とかで済むらしいんだけど念のための200回",
            "    for i in range(200):",
            "#         s0 = start",
            "        s1 = (2*start + end) //3",
            "        s2 = (start + 2*end) //3",
            "#         s3 = end",
            "",
            "        # 2箇所取得",
            "        s1_ans = tri_cal(s1, data)",
            "        s2_ans = tri_cal(s2, data)",
            "        ",
            "        ",
            "#         if s1_ans >= s2_ans: # 最小の時",
            "        if s1_ans <= s2_ans: # 最大の時",
            "            start = s1",
            "        else:",
            "            end = s2",
            "            ",
            "        # 終了条件(整数値で見ていくとき、最小は3以下になるはず)",
            "        if (end-start)<=3:",
            "            break",
            "            ",
            "    # ここのmin, maxは問題によって使い分け",
            "    return max(s1_ans, s2_ans)",
        ],
        "description": ""
    },
    "modinv": {
        "prefix": "modinv",
        "body": [
            "# modが素数じゃないとき",
            "def inv(a, b):# bがmod",
            "    if a == 1:",
            "        return 1",
            "    else:",
            "        return b + (-b * inv(b % a, a) + 1) // a",
        ],
        "description": ""
    },
    "yakusuu_no_rekkyo": {
        "prefix": "yakusuu_no_rekkyo",
        "body": [
            "def make_divisors(n):",
            "    divisors = []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i == 0:",
            "            divisors.append(i)",
            "            if i != n // i:",
            "                divisors.append(n//i)",
            "",
            "    # divisors.sort()",
            "    return divisors",
        ],
        "description": ""
    },
    "soinsuubunkai": {
        "prefix": "soinsuubunkai",
        "body": [
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    for i in range(2, int(-(-n**0.5//1))+1):",
            "        if temp%i==0:",
            "            cnt=0",
            "            while temp%i==0:",
            "                cnt+=1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "",
            "    if temp!=1:",
            "        arr.append([temp, 1])",
            "",
            "    if arr==[]:",
            "        arr.append([n, 1])",
            "",
            "    return arr",
        ],
        "description": ""
    },
    "toporojikaru_sort": {
        "prefix": "toporojikaru_sort",
        "body": [
            "# V: 頂点数",
            "# G[v] = [w, ...]:",
            "#    有向グラフ上の頂点vから到達できる頂点w",
            "# deg[v]:",
            "#    頂点vに到達できる頂点の数",
            "",
            "deq = []",
            "for v in range(V):",
            "    if deg[v+1] == 0:",
            "        deq.append(deg[v+1], v+1)",
            "heapq.heapify(deq)",
            "",
            "out = []",
            "while deq:",
            "    _, v = heapq.heappop(deq)",
            "    ",
            "    # deqには入り次数0のものだけはいるのでheapqで出てきたものが辞書順最小になる",
            "    if deg[v] == 0:",
            "        out.append(v)",
            "    ",
            "    for t in G[v]:",
            "        deg[t] -= 1",
            "        if deg[t]==0:",
            "            # (優先したい特徴量, ノード番号)で入れる",
            "            heapq.heappush(deq, (deg[t] ,t))",
            "            ",
            "# ans: トポロジカル順序に並べた頂点",
        ],
        "description": ""
    },
    "LIS": {
        "prefix": "LIS",
        "body": [
            "# Aの数列の中で最も長い単調増加の列を抜き出す",
            "",
            "import bisect",
            "def LIS(N, A):",
            "    INF = 1<<60",
            "    dp  = [INF] * N",
            "#     index_list = [0] * N",
            "",
            "    for i, a in enumerate(A):",
            "        ind = bisect.bisect_left(dp, a)",
            "        if dp_L[ind] > a:",
            "            dp_L[ind] = a",
            "        L_ind[i] = ind",
            "    ",
            "    return ",
        ],
        "description": ""
    },
    "ranrengusu": {
        "prefix": "ranrengusu",
        "body": [
            "from itertools import groupby",
            "",
            "# RUN LENGTH ENCODING str -> list(tuple())",
            "# example) \"aabbbbaaca\" -> [('a', 2), ('b', 4), ('a', 2), ('c', 1), ('a', 1)] ",
            "def runLengthEncode(S: str) -> \"List[tuple(str, int)]\":",
            "    grouped = groupby(S)",
            "    res = []",
            "    for k, v in grouped:",
            "        res.append((k, int(len(list(v)))))",
            "    return res",
            "",
            "# RUN LENGTH DECODING list(tuple()) -> str",
            "# example) [('a', 2), ('b', 4), ('a', 2), ('c', 1), ('a', 1)] -> \"aabbbbaaca\"",
            "def runLengthDecode(L: \"list[tuple]\") -> str:",
            "    res = \"\"",
            "    for c, n in L:",
            "        res += c * int(n)",
            "    return res",
            "",
            "# RUN LENGTH ENCODING str -> str",
            "# example) \"aabbbbaaca\" -> \"a2b4a2c1a1\" ",
            "def runLengthEncodeToString(S: str) -> str:",
            "    grouped = groupby(S)",
            "    res = \"\"",
            "    for k, v in grouped:",
            "        res += k + str(len(list(v)))",
            "    return res",
        ],
        "description": ""
    },
    "SegTree": {
        "prefix": "SegTree",
        "body": [
            "#####segfunc#####",
            "def segfunc(x, y):",
            "    return x+y",
            "#################",
            "",
            "#####ide_ele#####",
            "ide_ele = 0",
            "#################",
            "",
            "class SegTree:",
            "    \"\"\"",
            "    init(init_val, ide_ele): 配列init_valで初期化 O(N)",
            "    update(k, x): k番目の値をxに更新 O(logN)",
            "    query(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)",
            "    \"\"\"",
            "    def __init__(self, init_val, segfunc, ide_ele):",
            "        \"\"\"",
            "        init_val: 配列の初期値",
            "        segfunc: 区間にしたい操作",
            "        ide_ele: 単位元",
            "        n: 要素数",
            "        num: n以上の最小の2のべき乗",
            "        tree: セグメント木(1-index)",
            "        \"\"\"",
            "        self.n = len(init_val)",
            "        self.bitlen = (self.n - 1).bit_length()",
            "        self.segfunc = segfunc",
            "        self.ide_ele = ide_ele",
            "        self.num = 1 << self.bitlen",
            "        self.tree = [ide_ele] * 2 * self.num",
            "        # 配列の値を葉にセット",
            "        for i in range(self.n):",
            "            self.tree[self.num + i] = init_val[i]",
            "        # 構築していく",
            "        for i in range(self.num - 1, 0, -1):",
            "            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
            "",
            "    def update(self, k, x):",
            "        \"\"\"",
            "        k番目の値をxに更新",
            "        k: index(0-index)",
            "        x: update value",
            "        \"\"\"",
            "        k += self.num",
            "        self.tree[k] = x",
            "        while k > 1:",
            "            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
            "            k >>= 1",
            "",
            "    def query(self, l, r):",
            "        \"\"\"",
            "        [l, r)のsegfuncしたものを得る",
            "        l: index(0-index)",
            "        r: index(0-index)",
            "        \"\"\"",
            "        res = self.ide_ele",
            "",
            "        l += self.num",
            "        r += self.num",
            "        while l < r:",
            "            if l & 1:",
            "                res = self.segfunc(res, self.tree[l])",
            "                l += 1",
            "            if r & 1:",
            "                res = self.segfunc(res, self.tree[r - 1])",
            "            l >>= 1",
            "            r >>= 1",
            "        return res",
            "",
            "    # (累積がx以上のうち最も小さい値, その時のindex)を得る",
            "    # x以上のものが無ければ None を返す",
            "    def ge(self, x):",
            "        bits = 1",
            "        base = self.ide_ele",
            "        if self.tree[1] < x:",
            "            return (None, None)",
            "",
            "        for i in range(self.bitlen):",
            "            bits <<= 1",
            "            ne = self.segfunc(self.tree[bits], base) #左側のノードまでの累積を計算",
            "            if ne < x:",
            "                base = ne # 右側のノードに進むなら左側までの累積を保存",
            "                bits += 1",
            "        ind = bits - self.num",
            "        v = self.tree[bits]",
            "        return ind, v",
            "",
            "    # (累積がxを超える値のうち最も小さい値, その時のindex)を得る",
            "    # xを超えるものが無ければ None を返す",
            "    def gt(self, x): return self.ge(x+1)",
            "",
            "    # (累積がx以下のうち最も大きい値, その時のindex)を得る",
            "    # x以下のものが無ければ None を返す",
            "    def le(self, x):",
            "        if self.tree[self.num] > x:",
            "            return (None, None)",
            "",
            "        if self.tree[1] < x:",
            "            return self.n-1, self.tree[self.num-self.n-1]",
            "",
            "        bits = 1",
            "        base = self.ide_ele",
            "",
            "        for i in range(self.bitlen):",
            "            bits <<= 1",
            "            ne = self.segfunc(self.tree[bits], base) #左側のノードまでの累積を計算",
            "            if ne < x:",
            "                base = ne # 右側のノードに進むなら左側までの累積を保存",
            "                bits += 1",
            "        ind = bits - self.num",
            "        v = self.tree[bits]",
            "",
            "        if self.segfunc(base, v) == x:",
            "            return ind, v",
            "",
            "        return ind-1, self.tree[self.num - (ind-1)]  ",
            "",
            "    def lt(self, x): return self.le(x-1)",
        ],
        "description": ""
    },
    "01BFS": {
        "prefix": "01BFS",
        "body": [
            "# 以下の問題にてテスト済み",
            "# https://atcoder.jp/contests/abc213/tasks/abc213_e",
            "from collections import deque",
            "def zero_one_dfs():",
            "    global Ch, Cw, Dh, Dw, W, H, maps",
            "    out = 0",
            "    zero_deq = deque([(Ch-1, Cw-1)])",
            "#     cost_map = [[True] * W for i in range(H)]",
            "    cost_map = [[[1<<30, 1<<30, 1<<30, 1<<30] for j in range(W)]  for i in range(H)]",
            "",
            "    looks = [(-1, 0),(1, 0),(0, -1),(0, 1)]",
            "    count=0",
            "",
            "    while True:",
            "        one_deq = deque([])",
            "        ",
            "        while zero_deq:",
            "            now_y, now_x = zero_deq.pop()",
            "                ",
            "            # 目的地に到達したら",
            "            if (now_y == Dh-1) and (now_x == Dw-1):",
            "                return count",
            "",
            "            # 4近傍",
            "            # コスト0の時の移動パターン",
            "            for (y, x) in looks:",
            "                if (0 <= now_y + y <= H-1) and (0 <= now_x + x <= W-1):",
            "                    if maps[now_y + y][now_x + x] == \".\":",
            "                        if cost_map[now_y + y][now_x + x][dire] > count:",
            "                            cost_map[now_y + y][now_x + x][dire] = count",
            "                            zero_deq.append([now_y + y, now_x + x])",
            "",
            "            # コスト1の時の移動パターン",
            "            for y in range(-2, 3):",
            "                for x in range(-2, 3):",
            "                    if (0 <= now_y + y <= H-1) and (0 <= now_x + x <= W-1):",
            "                        if maps[now_y + y][now_x + x] == \"#\":",
            "                            if cost_map[now_y + y][now_x + x][temp] > count+1:",
            "                                cost_map[now_y + y][now_x + x][temp] = count+1",
            "                                one_deq.append([ now_y + y, now_x + x])",
            "",
            "#         print(*cost_map, sep=\"\\n\")",
            "#         print(one_deq)",
            "#         print()",
            "        # 辿り着けないとき-1",
            "        if len(one_deq)==0:",
            "            return -1",
            "        ",
            "        # コスト0で移動できるものがなくなったら",
            "        # 現在のコストを1増やし、コスト1で移動できるものを",
            "        # コスト0で移動できるものに移し替える",
            "        count+=1",
            "        zero_deq = one_deq",
        ],
        "description": ""
    },
    "wa-syaru_huroido_hukugen": {
        "prefix": "wa-syaru_huroido",
        "body": [
            "#入力",
            "INF = sys.maxsize",
            "cost = [[INF]*N for i in range(N)]",
            "nexts = [[INF]*N for i in range(N)]",
            "for y in range(N):",
            "    for x,m in enumerate(mi()):",
            "        cost[y][x]=m",
            "        nexts[y][x]=x",
            "",
            "# cost[i][j]: 頂点v_iから頂点v_jへ到達するための辺コストの和",
            "use_set = {i:{j:set([]) for j in range(i+1,N)} for i in range(N-1)}",
            "for k in range(N):",
            "    for i in range(N):",
            "        for j in range(i+1,N):",
            "            a,b = sorted([i, j])",
            "            if cost[i][k]!=INF and cost[k][j]!=INF:",
            "                if cost[i][j] > cost[i][k] + cost[k][j]:",
            "                    cost[i][j] = cost[i][k] + cost[k][j]",
            "                    nexts[i][j] = nexts[k][j]",
            "                    ",
            "def get_path(s, t):",
            "    global nexts",
            "    global cost",
            "    global v",
            "    cur = s",
            "    ret = []",
            "    ",
            "    while cur != t:",
            "        ret.append(cur)",
            "        cur = nexts[cur][t]",
            "        ",
            "    ret.append(t)",
            "    return ret",
        ],
        "description": ""
    },
    "DAIKUSUTORA_KEIROHUKUGEN": {
        "prefix": "DAIKUSUTORA_KEIROHUKUGEN",
        "body": [
            "from heapq import heappush, heappop",
            "##################################################################",
            "###################### TLEやREになる可能性がある ###################",
            "# ノード数2*10^5の時、　1 << 29 でRE ",
            "# ノード数2*10^5の時、　1 << 28 でTLE ",
            "# float(\"inf\")で問題なくAC",
            "INF = 1<<29 ## 値を指定するときはでかすぎるとエラーになるので絶対最適な値にすること",
            "INF = float(\"inf\")",
            "##################################################################",
            "",
            "# RG: 有向辺を反転させた有向グラフ, 無向グラフの時はそのままで良い",
            "def dijkstra(N, RG, s):",
            "    que = [(0, s)]",
            "    dist[s] = 0",
            "    ",
            "    while que:",
            "        c, v = heappop(que)",
            "        if dist[v] < c:",
            "            continue",
            "        for t, cost in RG[v]:",
            "            if dist[v] + cost < dist[t]:",
            "                dist[t] = dist[v] + cost",
            "                heappush(que, (dist[t], t))",
            "                ",
            "    return dist",
            "",
            "# GOALからSTARTに向けての最小移動をダイクストラで探索",
            "dist = dijkstra(N, RG, Y-1)",
            "",
            "# STARTからGOALに向けて最小の経路を復元していく(辞書順最小)",
            "# for文のminsをnow = vとしてbreakすればループが減ってもっとはやい",
            "# dist : ダイクストラで取得した最短コスト",
            "# G: 有向辺",
            "def keiro_hukugen(START, GOAL, dist, G):",
            "    ret = []",
            "    now = START",
            "    while now!=GOAL:",
            "",
            "        mins = INF",
            "        ret.append(now)",
            "        for v,c in G[now]:",
            "            if dist[v] + c == dist[now]:",
            "                 mins = min(mins, v)",
            "        now = mins",
            "    ret.append(GOAL)",
            "    return ret",
            "",
        ],
        "description": ""
    },
    "Mo's_algorithm": {
        "prefix": "Mo's_algorithm",
        "body": [
            "# offline queryをlについて平方分割、rについてしゃくとり法したもの",
            "import sys",
            "read = sys.stdin.readline",
            "",
            "from collections import defaultdict",
            "from operator import itemgetter",
            "",
            "class Mo:",
            "    def __init__(self, ls):",
            "        from math import sqrt, ceil",
            "        self.ls = ls",
            "        self.n = len(ls)",
            "        self.b = ceil(sqrt(self.n))  # bukectのサイズ及び個数",
            "",
            "    def _init_states(self):",
            "        ########################################",
            "        # self.states = None  # その時点における状態(自分で定義) #2つでもいい",
            "        self.n_unique = 0",
            "        self.cnt = defaultdict(lambda: 0)",
            "        ########################################",
            "",
            "        # [l,r)の半開区間で考える",
            "        self.l = 0",
            "        self.r = 0",
            "",
            "        # queryを格納する用",
            "        self.bucket = [list() for _ in range((self.b + 1))]",
            "",
            "    def _add(self, i):",
            "        # i番目の要素を含めて考えるときへstatesを更新",
            "        if self.cnt[self.ls[i]] == 0:",
            "            self.n_unique += 1",
            "        self.cnt[self.ls[i]] += 1",
            "",
            "    def _delete(self, i):",
            "        # i番目の要素を削除して考えるときへstatesを更新",
            "        self.cnt[self.ls[i]] -= 1",
            "        if self.cnt[self.ls[i]] == 0:",
            "            self.n_unique -= 1",
            "",
            "    def _one_process(self, l, r):",
            "        # クエリ[l,r)に対してstatesを更新する",
            "        for i in range(self.r, r):  # rまで伸長",
            "            self._add(i)",
            "        for i in range(self.r - 1, r - 1, -1):  # rまで短縮",
            "            self._delete(i)",
            "        for i in range(self.l, l):  # lまで短縮",
            "            self._delete(i)",
            "        for i in range(self.l - 1, l - 1, -1):  # lまで伸長",
            "            self._add(i)",
            "",
            "        self.l = l",
            "        self.r = r",
            "",
            "    def process(self, queries):",
            "        self._init_states()",
            "",
            "        for i, (l, r) in enumerate(queries):  # queryをbucketに格納",
            "            self.bucket[l // self.b].append((l, r, i))",
            "",
            "        for i in range(len(self.bucket)):",
            "            self.bucket[i].sort(key=itemgetter(1))",
            "    ",
            "        ret = [-1] * len(queries)",
            "        for b in self.bucket:",
            "            for l, r, i in b:  # クエリに答えていく",
            "                self._one_process(l, r)",
            "                ########################################",
            "                # クエリに答える作業をここで書く",
            "                ret[i] = self.n_unique",
            "                ########################################",
            "        return ret",
            "",
            "def ints(): return list(map(int, read().split()))",
            "input_count=0",
            "N, Q = ints()",
            "C = ints()",
            "queries = []",
            "for _ in range(Q):",
            "    l, r = ints()",
            "    queries.append((l - 1, r))",
            "",
            "mo = Mo(C)",
            "ans = mo.process(queries)",
            "print(*ans, sep='\\n')",
        ],
        "description": ""
    },
    "SortedMultiset": {
        "prefix": "SortedMultiset",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
            "import math",
            "from bisect import bisect_left, bisect_right, insort",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedMultiset(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(a)",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedMultiset\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def count(self, x: T) -> int:",
            "        \"Count the number of x.\"",
            "        return self.index_right(x) - self.index(x)",
            "",
            "    def add(self, x: T) -> None:",
            "        \"Add an element. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return",
            "        a = self._find_bucket(x)",
            "        insort(a, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": ""
    },
    "SortedSet": {
        "prefix": "SortedSet",
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
            "import math",
            "from bisect import bisect_left, bisect_right",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedSet(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(set(a))",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedSet\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def add(self, x: T) -> bool:",
            "        \"Add an element and return True if added. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return True",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i != len(a) and a[i] == x: return False",
            "        a.insert(i, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "        return True",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "    ",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "    ",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
        ],
        "description": ""
    },
    "Froid_no_junkankensyutu": {
        "prefix": "Froid_no_junkankensyutu",
        "body": [
            "# start = 初期位置",
            "# nxt = そのindexから次どこの地点に行くかのリストが入ったもの",
            "# 参考",
            "# https://atcoder.jp/contests/abc167/tasks/abc167_d",
            "def froids(start, nxt):",
            "    # フロイドの循環検出アルゴリズムここから",
            "    hare = tortoise = start  # 初期位置",
            "    while True:",
            "        hare = nxt[nxt[hare]]  # 2歩進む",
            "        tortoise = nxt[tortoise]  # 1歩進む",
            "        if hare == tortoise: break",
            "",
            "    hare = 0  # ウサギだけスタートに戻す",
            "    stepCountStartToLoopStart = 0  # スタートから巡回の開始位置までの距離",
            "",
            "    while True:",
            "        stepCountStartToLoopStart += 1",
            "        hare = nxt[hare]  # 1歩進む",
            "        tortoise = nxt[tortoise]  # 1歩進む",
            "        if hare == tortoise: break",
            "",
            "    nodeNumLoopStart = hare  # 循環の開始位置",
            "    cycleLen = 0  # 循環の長さ",
            "    hare = tortoise = nodeNumLoopStart",
            "    while True:",
            "        cycleLen += 1",
            "        tortoise = nxt[tortoise]",
            "        hare = nxt[nxt[hare]]",
            "        if tortoise == hare: break",
            "    # フロイドの循環検出アルゴリズムここまで",
            "    return nodeNumLoopStart, cycleLen, ",
        ],
        "description": ""
    },
    "zobrist_hash_only_syurui": {
        "prefix": "zobrist_hash_only_syurui",
        "body": [
            "import itertools as it",
            "import random",
            "from operator import xor",
            "from collections import defaultdict",
            "def gen_hash():",
            "    hash_dict = defaultdict(lambda: random.randint(1, (1 << 63) - 1))",
            "    Ax, Bx = [0] * N, [0] * N",
            "    AS, BS = set(), set()  # 既に出た値を管理",
            "    for i, (a, b) in enumerate(zip(A, B)):",
            "        if a not in AS:  # はじめて出るときだけxorをとる",
            "            Ax[i] = hash_dict[a]",
            "            AS.add(a)",
            "        if b not in BS:",
            "            Bx[i] = hash_dict[b]",
            "            BS.add(b)",
            "    A_acc = list(it.accumulate(Ax, xor))  # 累積和と同じ要領で累積xorをとる",
            "    B_acc = list(it.accumulate(Bx, xor))",
            "    return A_acc, B_acc",
        ],
        "description": ""
    },
    "zobrist_hash_syurui_and_kosuu": {
        "prefix": "zobrist_hash_syurui_and_kosuu",
        "body": [
            "import itertools as it",
            "import random",
            "from operator import add",
            "from collections import defaultdict",
            "def gen_hash():",
            "    hash_dict = defaultdict(lambda: random.randint(1, (1 << 63) - 1))",
            "    Ax, Bx = [0] * N, [0] * N",
            "    AS, BS = set(), set()  # 既に出た値を管理",
            "    for i, (a, b) in enumerate(zip(A, B)):",
            "        Ax[i] = hash_dict[a]",
            "        Bx[i] = hash_dict[b]",
            "    A_acc = list(it.accumulate(Ax, add))  # 累積和",
            "    B_acc = list(it.accumulate(Bx, add))",
            "    return A_acc, B_acc",
        ],
        "description": ""
    },
    "JIKKEN": {
        "prefix": "JIKKEN",
        "body": [
            "import random ",
            "",
            "for i in range(10000):",
            "    N = random.randint(10, 1000)",
            "    A = [random.randint(10, 1000) for _ in range(N)]",
            "    no = naive(N,A)",
            "    so = solve(N,A)",
            "    if no!=so:",
            "        print(N, no, so)",
            "        break",
        ],
        "description": ""
    },
    "LCM_many": {
        "prefix": "LCM",
        "body": [
            "N = int(input())   # Nは使わない",
            "S = list(map(int, input().split()))",
            "",
            "import functools",
            "import math",
            "",
            "def lcm2(x, y):",
            "    gcd = math.gcd(x, y)",
            "    return gcd * (x // gcd) * (y // gcd)",
            "",
            "gcd = lambda l: functools.reduce(math.gcd, l)",
            "lcm = lambda l: functools.reduce(lcm2, l)",
            "",
            "print(gcd(S), lcm(S))",
        ],
        "description": ""
    },
    "SAISYOU_ZENIKIGI": {
        "prefix": "SAISYOU_ZENIKIGI",
        "body": [
            "# E = [(cost, v, w), ...]",
            "#   G上の全ての辺(v, w)とそのcostを含むlist",
            "",
            "# Union-Findを使うことで頂点間の連結判定を行う",
            "*p, = range(N)",
            "def root(x):",
            "    if x == p[x]:",
            "        return x",
            "    p[x] = y = root(p[x])",
            "    return y",
            " ",
            "def unite(x, y):",
            "    px = root(x); py = root(y)",
            "    if px == py:",
            "        return 0",
            "    if px < py:",
            "        p[py] = px",
            "    else:",
            "        p[px] = py",
            "    return 1",
            " ",
            "E.sort()",
            "ans = 0",
            "for c, v, w in E:",
            "    if unite(v, w):",
            "        ans += c",
            "",
            "# ansが最小全域木の解",
        ],
        "description": ""
    },
    "DAIKUSUTORA": {
        "prefix": "DAIKUSUTORA",
        "body": [
            "# V: 頂点数",
            "# g[v] = {(w, cost)}:",
            "#     頂点vから遷移可能な頂点(w)とそのコスト(cost)",
            "# r: 始点の頂点",
            " ",
            "from heapq import heappush, heappop",
            "INF = float(\"inf\")",
            "def dijkstra(N, G, s):",
            "    dist = [INF] * N",
            "    que = [(0, s)]",
            "    dist[s] = 0",
            "    while que:",
            "        c, v = heappop(que)",
            "        if dist[v] < c:",
            "            continue",
            "        for t, cost in G[v]:",
            "            if dist[v] + cost < dist[t]:",
            "                dist[t] = dist[v] + cost",
            "                heappush(que, (dist[t], t))",
        ],
        "description": ""
    },

    "WARSYARU_HUROIDO": {
        "prefix": "WA=SYARU_HUROIDO",
        "body": [
            "# cost[i][j]: 頂点v_iから頂点v_jへ到達するための辺コストの和",
            "for k in range(V):",
            "    for i in range(V):",
            "        for j in range(V):",
            "            if cost[i][k]!=INF and cost[k][j]!=INF:",
            "                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])",
        ],
        "description": ""
    },
    "SCC": {
        "prefix": "SCC",
        "body": [
            "# 強連結成分分解(SCC): グラフGに対するSCCを行う",
            "# 入力: <N>: 頂点サイズ, <edges>: 順方向の有向グラフ",
            "# 出力: (サイクル毎にリストになったリスト)",
            "# 計算量 O(E+V)",
            "    ",
            "## このような形でedgesを取得して下さい",
            "# for i in range(LOOP_NUM):",
            "#   a,b = mi()",
            "#   edges.append((a-1,b-1))",
            "def scc(N,edges):",
            "    M=len(edges)",
            "    start=[0]*(N+1)",
            "    elist=[0]*M",
            "    for e in edges:",
            "        start[e[0]+1]+=1",
            "    for i in range(1,N+1):",
            "        start[i]+=start[i-1]",
            "    counter=start[:]",
            "    for e in edges:",
            "        elist[counter[e[0]]]=e[1]",
            "        counter[e[0]]+=1",
            "    visited=[]",
            "    low=[0]*N",
            "    Ord=[-1]*N",
            "    ids=[0]*N",
            "    NG=[0,0]",
            "    def dfs(v):",
            "        stack=[(v,-1,0),(v,-1,1)]",
            "        while stack:",
            "            v,bef,t=stack.pop()",
            "            if t:",
            "                if bef!=-1 and Ord[v]!=-1:",
            "                    low[bef]=min(low[bef],Ord[v])",
            "                    stack.pop()",
            "                    continue",
            "                low[v]=NG[0]",
            "                Ord[v]=NG[0]",
            "                NG[0]+=1",
            "                visited.append(v)",
            "                for i in range(start[v],start[v+1]):",
            "                    to=elist[i]",
            "                    if Ord[to]==-1:",
            "                        stack.append((to,v,0))",
            "                        stack.append((to,v,1))",
            "                    else:",
            "                        low[v]=min(low[v],Ord[to])",
            "            else:",
            "                if low[v]==Ord[v]:",
            "                    while(True):",
            "                        u=visited.pop()",
            "                        Ord[u]=N",
            "                        ids[u]=NG[1]",
            "                        if u==v:",
            "                            break",
            "                    NG[1]+=1",
            "                low[bef]=min(low[bef],low[v])",
            "    for i in range(N):",
            "        if Ord[i]==-1:",
            "            dfs(i)",
            "    for i in range(N):",
            "        ids[i]=NG[1]-1-ids[i]",
            "    group_num=NG[1]",
            "    counts=[0]*group_num",
            "    for x in ids:",
            "        counts[x]+=1",
            "    groups=[[] for i in range(group_num)]",
            "    for i in range(N):",
            "        groups[ids[i]].append(i)",
            "    return groups",
            "",
        ],
        "description": ""
    },
    "DFS_WHILE": {
        "prefix": "DFS_WHILE",
        "body": [
            "from collections import deque",
            "reached = [0] * N ## 1つ前のノードを持たせると微妙に遅くなるのでやめよう",
            "deq = deque([])",
            "",
            "while deq:",
            "",
            "    node = deq.pop() #DFS",
            "    #node = deq.popleft() #BFS",
            "    reached[node] = -1",
            "",
            "    for next_node in maps[node]:",
            "        # 訪問済み判定",
            "        if reached[next_node] == -1:",
            "            continue",
            "        ",
            "        reached.add(next_node)",
            "        deq.append(next_node)",
            "",
            "            ",
        ],
        "description": ""
    },
    "GRAPH_INPUT": {
        "prefix": "GRAPH_INPUT",
        "body": [
            "NODE = N",
            "LOOP_NUM = M",
            "maps = {i:[] for i in range(NODE)}",
            "for i in range(LOOP_NUM):",
            "    a,b = mi()",
            "    maps[a-1].append(b-1)",
            "    maps[b-1].append(a-1)",
        ],
        "description": ""
    },

    "daburing": {
        "prefix": "daburing",
        "body": [
            "N, K = mi()",
            "A = mi()",
            "",
            "# 最大操作回数よりも大きい2^LOGのLOGをいれる",
            "LOG = ",
            "",
            "# ダブリングのテーブル",
            "dp = [[0 for j in range(N)] for i in range(LOG)]",
            "# dp_sum = [[0 for j in range(N)] for i in range(LOG)]  # 加算していくタイプ用",
            "",
            "# 初期条件",
            "for i in range(N):",
            "    # 初期の遷移を全て網羅することで2^i回目でも遷移できるようにする",
            "    dp[0][i] = (A[i]+i)%N",
            "    # dp_sum[0][i] = A[i]  # 加算していくタイプ用",
            "",
            "# 遷移(2のベキ回)",
            "for i in range(1, LOG):",
            "    for j in range(N):",
            "        ind = dp[i - 1][j]",
            "        dp[i][j] = dp[i - 1][ind]",
            "",
            "        # ind_dp_val = dp_sum[i - 1][j] # 加算していくタイプ用",
            "        # dp_sum[i][j] = dp_sum[i - 1][ind] + ind_dp_val # 加算していくタイプ用",
            "",
            "",
            "",
            "# 解を求める",
            "i = 0",
            "answer = 0",
            "out = 0",
            "while K:",
            "    if K & 1:",
            "        # out += dp_sum[i][answer] # 加算していくタイプ用",
            "        answer = dp[i][answer]",
            "    K >>= 1",
            "    i += 1",
        ],
        "description": ""
    },
    "DFS_TREE": {
        "prefix": "DFS_TREE",
        "body": [
            "# 入力:maps, キーにキーから繋がるノードのリスト",
            "# 出力:入力と同じ形式のdfs木のリスト",
            "def DFS_TREE(N, maps):",
            "    from collections import deque",
            "    reached = [0] * N ## 1つ前のノードを持たせると微妙に遅くなるのでやめよう",
            "    deq = deque([(0,0)])",
            "    dfs_maps = {i:[] for i in range(N)}",
            "",
            "    while deq:",
            "        node,old_node = deq.pop() #DFS",
            "        if reached[node]==-1:",
            "            continue",
            "",
            "        if not(node==old_node==0):",
            "            dfs_maps[node].append(old_node)",
            "",
            "        reached[node] = -1",
            "",
            "        for next_node in maps[node]:",
            "            # 訪問済み判定",
            "            if reached[next_node] == -1:",
            "                continue",
            "            deq.append((next_node, node))",
            "    return dfs_maps",
        ],
        "description": ""
    },
    "BFS_TREE": {
        "prefix": "BFS_TREE",
        "body": [
            "# 入力:maps, キーにキーから繋がるノードのリスト",
            "# 出力:入力と同じ形式のbfs木のリスト",
            "def BFS_TREE(N, maps):",
            "    from collections import deque",
            "    reached = [0] * N ## 1つ前のノードを持たせると微妙に遅くなるのでやめよう",
            "    deq = deque([(0,0)])",
            "    bfs_maps = {i:[] for i in range(N)}",
            "    while deq:",
            "        node,old_node = deq.popleft() #BFS",
            "        ",
            "        if reached[node]==-1:",
            "            continue",
            "        if not(node==old_node==0):",
            "            bfs_maps[node].append(old_node)",
            "",
            "        reached[node] = -1",
            "",
            "        for next_node in maps[node]:",
            "            # 訪問済み判定",
            "            if reached[next_node] == -1:",
            "                continue",
            "            deq.append((next_node, node))",
            "    return bfs_maps",
        ],
        "description": ""
    },
    "KETA_DP": {
        "prefix": "KETA_DP",
        "body": [
            "from itertools import product",
            "",
            "length=len(N)",
            "dp_miman = [[0]*10 for _ in range(length+1)]",
            "dp_equal = [[0]*10 for _ in range(length+1)]",
            "",
            "dp_equal[0][int(N[0])] =int(N[0]) ",
            "for i in range(1, int(N[0])):",
            "    dp_miman[0][i] = i",
            "",
            "for i, num1, num2 in product(range(1,length), range(10), range(10)):",
            "",
            "    ######## 一致からの遷移 #######",
            "    if str(num2)==N[i]:",
            "        # 0だったらzeroカウントを1追加",
            "        dp_equal[i][num2] = max(dp_equal[i-1][num1]+num2,dp_equal[i][num2])",
            "",
            "    #一致から未満へ",
            "    elif str(num2)<N[i]:",
            "        # 0だったらzeroカウントを1追加",
            "        dp_miman[i][num2] = max(dp_miman[i][num2], dp_equal[i-1][num1] +num2) ",
            "    ",
            "",
            "    ######## 未満から未満へ #######",
            "    dp_miman[i][num2] = max(dp_miman[i-1][num1] + num2, dp_miman[i][num2])",
        ],
        "description": ""
    },
    "ERATOSUTENESU": {
        "prefix": "ERATOSUTENESU",
        "body": [
            "# エラトステネスの篩",
            "# 用意してないよ",
            "# 重要な点 : 掛け算で追う形は計算量が思ったより少ないよ",
            "# O(N * logN)",
            "import math",
            "for K in range(1, 8):",
            "    N = 10**K",
            "    count = 0",
            "    for i in range(1,N+1):",
            "        for j in range(i, N+1, i):",
            "            count += 1",
            "    print(N, count, math.log(N), count/N)",
        ],
        "description": ""
    },
    "MAKE_TREE": {
        "prefix": "MAKE_TREE",
        "body": [
            "# N頂点の木を作成する",
            "import random",
            "def make_tree(N):",
            "    # ノードN個の木を作成",
            "    N = random.randint(1, 10)",
            "    G =  {i:[] for i in range(N)}",
            "    uf = UnionFind(N)",
            "    use_cost = True",
            "    out_list = []",
            "",
            "    # 連結になるまでループ",
            "    while uf.size(0) != N:",
            "        A = random.randint(1, N)",
            "        B = random.randint(1, N)",
            "        if A==B:",
            "            continue",
            "",
            "        # 連結でなければ追加",
            "        A,B  =sorted([A,B])",
            "        if not uf.same(A-1, B-1):",
            "            uf.union(A-1,B-1)",
            "            # costはいらない",
            "            G[A-1].append(B-1)",
            "            G[B-1].append(A-1)",
            "            out_list.append((A, B))",
            "",
            "    # 1-indexdのリストを作る",
            "    return out_list",
        ],
        "description": ""
    },
    "MAKE_GRAPH_MUKOU": {
        "prefix": "MAKE_GRAPH_MUKOU",
        "body": [
            "# N頂点の木を作成する",
            "import random",
            "# N頂点、M辺",
            "def make_graph_mukou(N, M, renketu_flg):",
            "    # ノードN個を作成",
            "    out_list = []",
            "",
            "    if renketu_flg:",
            "        uf = UnionFind(N)",
            "        # 連結になるまでループ",
            "        while uf.size(0) != N:",
            "            A = random.randint(1, N)",
            "            B = random.randint(1, N)",
            "            cost = random.randint(1, 2*N)",
            "            if A==B:",
            "                continue",
            "",
            "            # 連結でなければ追加",
            "            A,B  =sorted([A,B])",
            "            if not uf.same(A-1, B-1):",
            "                uf.union(A-1,B-1)",
            "                out_list.append((A, B))",
            "    else:",
            "        count = 0",
            "        sets = set([])",
            "        while count != M:",
            "            A = random.randint(1, N)",
            "            B = random.randint(1, N)",
            "            cost = random.randint(1, 2*N)",
            "",
            "            if A==B:",
            "                continue",
            "",
            "            # 同じ辺が無ければ追加",
            "            A,B  =sorted([A,B])",
            "            if (A-1, B-1) not in sets:",
            "                # costはいらない",
            "                out_list.append((A, B, cost))",
            "                count += 1",
            "    # 1-indexdのリストを作る",
            "    return out_list",
            "",
            "",
            "make_graph_mukou(10, 4, renketu_flg=False)",
        ],
        "description": ""
    },
    "gyouretu_seki": {
        "prefix": "gyouretu_seki",
        "body": [
            "# 列ベクトルのリストが欲しいよ",
            "def mult_prod(l_d, l_c):",
            "    l_mult=[]",
            "    for row in l_c:",
            "        temp=[]",
            "        for col in zip(*l_d):",
            "            elm=0",
            "            for row_nth,col_nth in zip(row,col):",
            "                elm+=row_nth*col_nth",
            "            temp.append(elm)",
            "        l_mult.append(temp)",
            "    return l_mult",
        ],
        "description": ""
    },
    "COMB": {
        "prefix": "COMB",
        "body": [
            "def cmb(n, r, mod):",
            "    if ( r<0 or r>n ):",
            "        return 0",
            "    r = min(r, n-r)",
            "    return (g1[n] * g2[r])%mod * g2[n-r] % mod",
            "",
            "mod = 10**9+7 #出力の制限",
            "CN = 10**5",
            "g1 = [1, 1] # 元テーブル",
            "g2 = [1, 1] #逆元テーブル",
            "inverse = [0, 1] #逆元テーブル計算用テーブル",
            "",
            "for i in range( 2, CN + 1 ):",
            "    g1.append( ( g1[-1] * i ) % mod )",
            "    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )",
            "    g2.append( (g2[-1] * inverse[-1]) % mod )",
            "",
            "# use sample",
            "# a = cmb(n,r,mod)",
            "",
            "# 単発で計算",
            "# n + min(n-r,r) +1 回の計算でいける",
            "def cmb(n,r, mod=None):",
            "    # n! / (r! * (n-r)! )",
            "    # rとn-rの小さいほうをrとする",
            "    r = min(n-r, r)",
            "",
            "    bunsi = 1",
            "    for i in range(n, n-r, -1):",
            "        bunsi  *= i",
            "        # bunsi = (bunsi * i)%mod",
            "",
            "    bunbo = 1",
            "    for i in range(2, r+1):",
            "        bunbo *= i",
            "        # bunbo = (bunbo * i)%mod",
            "",
            "    return bunsi//bunbo",
            "    # return bunsi*pow(bunbo, mod-2, mod)",
            "",
            "# 重複組み合わせ",
            "def tyouhuku_kumiawase(n, k):",
            "    # nHk = n+r-1 C k",
            "    return cmb(n+r-1, k, mod)",
            "",
        ],
        "description": ""
    },
    "NIJIGEN_RUISEKIWA": {
        "prefix": "NIJIGEN_RUISEKIWA",
        "body": [
            "class CumulativeSum2D:",
            "    #累積和テーブルを作成する",
            "    def __init__(self, S) -> None:",
            "        '''",
            "        S:累積前の元のテーブル",
            "        '''",
            "        self.H=len(S)",
            "        self.W=len(S[0])",
            "        self.S=S",
            " ",
            "        #一番上と一番左は０の累積和テーブルを作成する。",
            "        self.cum=[[0]*(self.W+1) for _ in range(self.H+1)]",
            " ",
            "        for h in range(self.H):",
            "            for w in range(self.W):",
            "                self.cum[h+1][w+1]=self.cum[h+1][w]+self.cum[h][w+1]-self.cum[h][w]+self.S[h][w]",
            " ",
            "    #指定した範囲の累積和を取る",
            "    def sum(self, h1, w1, h2, w2):",
            "        '''",
            "        h1:右下の座標の縦方向の位置。3個目なら3",
            "        w1:右下の座標の横方向の位置。3個目なら3",
            "        h2:左上の座標の縦方向の位置。3個目なら3",
            "        w2:左上の座標の横方向の位置。3個目なら3",
            "        '''",
            "        return self.cum[h1][w1]-self.cum[h1][w2]-self.cum[h2][w1]+self.cum[h2][w2]",
            "      ",
            "# 左上の(sx,sy), 右上の(tx,ty)",
            "def get_2D_acc(sx,sy, tx, ty):",
            "    alls = maps[ty][tx]",
            "    diff1 = maps[ty][sx-1]",
            "    diff2 = maps[sy-1][tx]",
            "    add = maps[sy-1][sx-1]",
            "    return alls - diff1 - diff2 + add",
        ],
        "description": ""
    },

    "IMOS_2D_ADD": {
        "prefix": "IMOS_2D_ADD",
        "body": [
            "# 0-index",
            "def imos_2d_add(sx,sy, tx,ty):",
            "    H_max = len(maps)",
            "    W_max = len(maps[0])",
            "",
            "    maps[sy][sx] += 1",
            "    if H_max > ty+1:",
            "        maps[ty+1][sx] -= 1",
            "    if W_max > tx+1:",
            "        maps[sy][tx+1] -= 1",
            "",
            "    if W_max > tx+1 and H_max > ty+1:",
            "        maps[ty+1][tx+1] += 1",
            "",
        ],
        "description": ""
    },
    "BinaryTrie": {
        "prefix": "BinaryTrie",
        "body": [
            "class BinaryTrie:",
            "    def __init__(self, bitlen=30):",
            "        # 0の子, 1の子、部分木のノード数, 重複数(何個同じ値があるか)",
            "        self.root = [None, None, 0, 0]",
            "        self.bitlen = bitlen",
            "",
            "    #要素の追加",
            "    def append(self,x):",
            "        # rootからスタート",
            "        node = self.root",
            "        node[2] += 1",
            "        node[3] += x",
            "        kari = 1 << (self.bitlen-1)",
            "",
            "        for _ in range(self.bitlen):",
            "            # その階層のbitを取得",
            "            b = 1 if x & kari > 0 else 0",
            "            if node[b] is None:",
            "                # 何故か4つめを0にしてb==0のとき+xしたら使用メモリ増えた",
            "                if b==0:",
            "                    node[b] = [None, None, 1, x]",
            "                else:",
            "                    node[b] = [None, None, 1, 0]",
            "            else:",
            "                # 部分木のノード数加算",
            "                node[b][2] += 1",
            "                # 部分木の合計",
            "                if b==0:",
            "                    # 0の時だけ足す",
            "                    node[b][3] += x",
            "",
            "            # 見る場所を1bit右に変更",
            "            kari = kari >> 1",
            "            node = node[b]",
            "",
            "    #要素の削除",
            "    def remove(self,x):",
            "        node = self.root",
            "        kari = 1 << (self.bitlen-1)",
            "        node[2] -= 1",
            "        node[3] -= x",
            "",
            "        for _ in range(self.bitlen):",
            "            # その階層のbitを取得",
            "            b = 1 if x & kari > 0 else 0",
            "            if node[b] is None:",
            "                return",
            "            else:",
            "                # 部分木の子の数が1しかなければその部分木は丸ごと削除される",
            "                if node[b][2] == 1:",
            "                    node[b] = None",
            "                    return",
            "",
            "                # 部分木のノード数加算",
            "                node[b][2] -= 1",
            "                # 葉ノードの時,合計値減算",
            "                if b==0:",
            "                    node[b][3] -= x",
            "",
            "            # 見る場所を1bit右に変更",
            "            kari = kari >> 1",
            "            node = node[b]",
            "",
            "    #x以上のうち最小の要素の番号を得る",
            "    # x以上のものが無ければ None を返す",
            "    # same_flgがTrueならxと同じ値が2つ以上登録されてたらそれを返す",
            "    def lower_bound(self, x, same_flg=False):",
            "        # [1].一旦下にまで下がってから登る。",
            "        #   →  [1.1].下がってる最中に大きいほうへの分岐があったら都度保存",
            "        #   →  [1.2].下がれなくなったらそこで[2]へ",
            "        # [2].[1]で保存した大きいほうへの分岐からず～～～～っと小さいほうへ遷移し続ける。",
            "",
            "        node = self.root",
            "        kari = 1 << (self.bitlen-1)",
            "",
            "        bunki_num = None",
            "        bunki_bit = None",
            "        bunki_node = None",
            "        bunki_i = None",
            "",
            "        num = 0",
            "        for i in range(self.bitlen):",
            "            # その階層のbitを取得",
            "            b = 1 if x & kari > 0 else 0",
            "",
            "            ## [1.1] 大きいほうへの分岐があったら保存####",
            "            if b==0:",
            "                if node[1] is not None:",
            "                    bunki_num = num+kari",
            "                    bunki_bit = kari>>1",
            "                    bunki_node = node[1]",
            "                    bunki_i = i+1",
            "            ##########################################",
            "",
            "            num += kari*b",
            "            kari = kari >> 1",
            "",
            "            # 次のノードへの遷移",
            "            node = node[b]",
            "",
            "            # もう移動できるノードが無ければ(二分探索で存在しないデータで探索するとき用)",
            "            # [1.2]",
            "            if node is None:",
            "                break",
            "",
            "        if same_flg:",
            "            if node is not None and node[2] >= 2:",
            "                return num",
            "",
            "        # もし大きいほうへの分岐が無ければ",
            "        if bunki_num is None:",
            "            return None",
            "",
            "        ######## [2] ########",
            "        # あったら",
            "        for i in range(bunki_i, self.bitlen):",
            "            # 小さいほうへ優先的に分岐",
            "            if bunki_node[0] is not None:",
            "                bunki_node = bunki_node[0]",
            "            else:",
            "                bunki_node = bunki_node[1]",
            "                bunki_num += bunki_bit",
            "",
            "            bunki_bit = bunki_bit >> 1",
            "        return bunki_num",
            "",
            "    # #xより大きい数のうち最小の要素の番号を得る",
            "    # x未満のものが無ければ None を返す",
            "    # same_flgがTrueならxと同じ値が2つ以上登録されてたらそれを返す",
            "    def upper_bound(self, x, same_flg=False):",
            "        # [1].一旦下にまで下がってから登る。",
            "        #   →  [1.1].下がってる最中に小さいほうへの分岐があったら都度保存",
            "        #   →  [1.2].下がれなくなったらそこで[2]へ",
            "        # [2].[1]で保存した小さいほうへの分岐からず～～～～っと大きいほうへ遷移し続ける。",
            "",
            "        node = self.root",
            "        kari = 1 << (self.bitlen-1)",
            "",
            "        bunki_num = None",
            "        bunki_bit = None",
            "        bunki_node = None",
            "        bunki_i = None",
            "",
            "        num = 0",
            "        for i in range(self.bitlen):",
            "            # その階層のbitを取得",
            "            b = 1 if x & kari > 0 else 0",
            "",
            "            ## [1.1] 小さいほうへの分岐があったら保存####",
            "            if b==1:",
            "                if node[0] is not None:",
            "                    bunki_num = num",
            "                    bunki_bit = kari>>1",
            "                    bunki_node = node[0]",
            "                    bunki_i = i+1",
            "            ##########################################",
            "",
            "            num += kari*b",
            "            kari = kari >> 1",
            "",
            "            # 次のノードへの遷移",
            "            node = node[b]",
            "",
            "            # もう移動できるノードが無ければ(二分探索で存在しないデータで探索するとき用)",
            "            # [1.2]",
            "            if node is None:",
            "                break",
            "",
            "        if same_flg:",
            "            if node is not None and node[2] >= 2:",
            "                return num",
            "",
            "        # もし小さいほうへの分岐が無ければ",
            "        if bunki_num is None:",
            "            return None",
            "",
            "        ######## [2] ########",
            "        # あったら",
            "        for i in range(bunki_i, self.bitlen):",
            "            # 大きいほうへ優先的に分岐",
            "            if bunki_node[1] is not None:",
            "                bunki_node = bunki_node[1]",
            "                bunki_num += bunki_bit",
            "            else:",
            "                bunki_node = bunki_node[0]",
            "",
            "            bunki_bit = bunki_bit >> 1",
            "        return bunki_num",
            "",
            "    # #k番目の値を返す",
            "    def kth_element(self, k):",
            "        node = self.root",
            "        kari = 1 << (self.bitlen-1)",
            "        num, temp = 0,0",
            "        for _ in range(self.bitlen):",
            "            # # どこにもいけない",
            "            # if node[0] is None and node[1] is None: return None",
            "            # 今のノードで既にK未満なら終わり",
            "            if temp+node[2] < k: return None",
            "            # ルートが1つしかない",
            "            if   node[0] is None: node = node[1]; num+=kari",
            "            elif node[1] is None: node = node[0]",
            "",
            "            # ルートが2つある",
            "            # 0の子の部分木の数がk以上なとき",
            "            elif k <= node[0][2]+temp: node = node[0]",
            "            # 1の子だけ足りているとき",
            "            elif node[2]+temp >= k:",
            "                temp += node[0][2]",
            "                node = node[1]",
            "                num += kari",
            "            kari = kari >> 1",
            "        return num",
            "",
            "    # #k個の合計値を返す",
            "    def kth_sum(self, k):",
            "        node = self.root",
            "        kari = 1 << (self.bitlen-1)",
            "        num, temp, temp_sum = 0,0, 0",
            "        for _ in range(self.bitlen):",
            "            # # どこにもいけない",
            "            # if node[0] is None and node[1] is None: return None",
            "            # 今のノードで既にK未満なら終わり",
            "            if temp+node[2] < k: return None",
            "            # ルートが1つしかない",
            "            if   node[0] is None: node = node[1]; num+=kari",
            "            elif node[1] is None: node = node[0]",
            "",
            "            # ルートが2つある",
            "            # 0の子の部分木の数がk以上なとき",
            "            elif k <= node[0][2]+temp: ",
            "                node = node[0]",
            "            # 1の子だけ足りているとき",
            "            elif node[2]+temp >= k:",
            "                temp += node[0][2]",
            "                temp_sum += node[0][3]",
            "                node = node[1]",
            "                num += kari",
            "            kari = kari >> 1",
            "        ",
            "        return temp_sum + (k-temp) * num",
            "",
        ],
        "description": ""
    },
    "BinaryTrie2": {
        "prefix": "BinaryTrie2",
        "body": [
            "class BinaryTrie:",
            "    def __init__(self, bitlen=30):",
            "        self.nodes = [1,-1,-1]",
            "        self.cnt = [0,0,0]",
            "        self.sum = [0,0,0]",
            "        self.id = 3",
            "        self.bitlen = bitlen",
            "",
            "    #要素の追加",
            "    def append(self,x, n=1):",
            "        pt = 0",
            "        x = x*n",
            "        kari = 1 << (self.bitlen-1)",
            "        for _ in range(self.bitlen):",
            "            self.cnt[pt] += n",
            "            self.sum[pt] += x",
            "            if x & kari:",
            "                pt = self.nodes[pt] + 1",
            "            else:",
            "                pt = self.nodes[pt]",
            "            if self.nodes[pt] == -1:",
            "                self.nodes[pt] = self.id",
            "                self.id += 2",
            "                self.cnt.append(0)",
            "                self.cnt.append(0)",
            "                self.sum.append(0)",
            "                self.sum.append(0)",
            "                self.nodes.append(-1)",
            "                self.nodes.append(-1)",
            "            kari = kari >> 1",
            "        self.cnt[pt] += n",
            "        self.sum[pt] += x",
            "",
            "    #要素の削除",
            "    def remove(self,x,n=1):",
            "        pt = 0",
            "        kari = 1 << (self.bitlen-1)",
            "        mm = self.find(x)",
            "        n = min(mm,n)",
            "        xx = x*n",
            "        for _ in range(self.bitlen):",
            "            self.cnt[pt] -= n",
            "            self.sum[pt] -= xx",
            "            if x & kari:",
            "                pt = self.nodes[pt] + 1",
            "            else:",
            "                pt = self.nodes[pt]",
            "            if self.nodes[pt] == -1:",
            "                self.nodes[pt] = self.id",
            "                self.id += 2",
            "                self.cnt.append(0)",
            "                self.cnt.append(0)",
            "                self.sum.append(0)",
            "                self.sum.append(0)",
            "                self.nodes.append(-1)",
            "                self.nodes.append(-1)",
            "            kari = kari >> 1",
            "        self.cnt[pt] -= n",
            "        self.sum[pt] -= xx",
            "",
            "    #要素の検索",
            "    # 存在するとき、個数を返す",
            "    def find(self,x):",
            "        pt = 0",
            "        kari = 1 << (self.bitlen-1)",
            "        for _ in range(self.bitlen):",
            "            if x & kari:",
            "                pt = self.nodes[pt] + 1",
            "            else:",
            "                pt = self.nodes[pt]",
            "            if self.nodes[pt] == -1:",
            "                return 0",
            "            kari = kari >> 1",
            "        return self.cnt[pt]",
            "",
            "    #x以上のうち最小の要素の番号を得る",
            "    def lower_bound(self,x,xorval=0):",
            "        pt = 0",
            "        num = 0",
            "        kari = 1 << (self.bitlen-1)",
            "        for _ in range(self.bitlen):",
            "            if x & kari:",
            "                num += self.cnt[self.nodes[pt]]",
            "                pt = self.nodes[pt] + 1",
            "            else:",
            "                pt = self.nodes[pt]",
            "            if self.nodes[pt] == -1:",
            "                break",
            "            kari = kari >> 1",
            "        return num+1",
            "",
            "    #xより大きい数のうち最小の要素の番号を得る",
            "    def upper_bound(self,x,xorval=0):",
            "        pt = 0",
            "        num = 0",
            "        kari = 1 << (self.bitlen-1)",
            "        for _ in range(self.bitlen):",
            "            if x & kari:",
            "                num += self.cnt[self.nodes[pt]]",
            "                pt = self.nodes[pt] + 1",
            "            else:",
            "                pt = self.nodes[pt]",
            "            if self.nodes[pt] == -1:",
            "                break",
            "            kari = kari >> 1",
            "        num += self.cnt[pt]",
            "        return num+1",
            "",
            "    #k番目の値を返す",
            "    def kth_element(self, k, xorval=0):",
            "        val = 0",
            "        pt = 0",
            "        kari = 1 << (self.bitlen-1)",
            "        for _ in range(self.bitlen):",
            "            if k > self.cnt[self.nodes[pt]]:",
            "                k -= self.cnt[self.nodes[pt]]",
            "                pt = self.nodes[pt] + 1",
            "                val += kari",
            "            else:",
            "                pt = self.nodes[pt]",
            "            if self.nodes[pt] == -1:",
            "                break",
            "            kari = kari >> 1",
            "        return val",
            "",
            "    #k番目までの合計を返す",
            "    def kth_sum(self, k, xorval=0):",
            "        val = 0",
            "        pt = 0",
            "        kari = 1 << (self.bitlen-1)",
            "        temp = 0",
            "        for _ in range(self.bitlen):",
            "            if k > self.cnt[self.nodes[pt]]:",
            "                k -= self.cnt[self.nodes[pt]]",
            "                temp += self.sum[self.nodes[pt]]",
            "                pt = self.nodes[pt] + 1",
            "                val += kari",
            "            else:",
            "                pt = self.nodes[pt]",
            "            if self.nodes[pt] == -1:",
            "                break",
            "            kari = kari >> 1",
            "        return temp+k*val",
            "",
        ],
        "description": ""
    },

    "GYOURETU_RUIJOU": {
        "prefix": "GYOURETU_RUIJOU",
        "body": [
            "def dot(A1,A2,n):",
            "  # n:行列のサイズ",
            "  A = [[0]*n for _ in range(n)]",
            "  for i in range(n):",
            "    for j in range(n):",
            "      for k in range(n):",
            "        A[i][j] += A1[i][k]*A2[k][j]",
            "  return A",
            "",
            "def pow_mat(A,k,n):",
            "  # A:累乗する行列, k:累乗数, n:行列Aのサイズ",
            "  P = [[0]*n for _ in range(n)]",
            "  for i in range(n): P[i][i] = 1",
            "  while k:",
            "    if k&1: P = dot(P,A,n)",
            "    A = dot(A,A,n)",
            "    k >>= 1",
            "  return P",
        ],
        "description": ""
    },
    "BAKEMONO": {
        "prefix": "BAKEMONO",
        "body": [
            "#### Q.これは何ですか? ####",
            "#### A.個数と値を別々で持つテクを忘れないようにclassにしたものです。",
            "# 出来ること",
            "# k番目までの和/積を取得 : log(N)",
            "#  →　これは累積が単調増加になることが条件",
            "# 最大,最小値取得 : log(N)",
            "# セグ木上の二分探索(upper_boundsのみ):log(N)",
            "#  →　これは累積が単調増加になることが条件",
            "# その他セグ木で出来る操作",
            "class BAKEMONO:",
            "    # A : 先読みした配列",
            "    def __init__(self, init_list):",
            "        # 使えるインデックスの組と使用済みのインデックスの組を作成",
            "        self.index_list = {}",
            "        self.used_index_list = {}",
            "        for i,n in enumerate(init_list):",
            "            if n in self.index_list:",
            "                self.index_list[n].append(i)",
            "            else:",
            "                self.index_list[n] = [i]",
            "                self.used_index_list[n] = []",
            "",
            "        def segfunc_kosu(x, y): return x+y",
            "        #####segfunc#####",
            "        def segfunc_sum(x, y): return x+y",
            "        ide_ele = 0",
            "        #################",
            "",
            "        self.kosu = SegTree([0]*len(init_list), segfunc_kosu, 0)",
            "        self.sum = SegTree([ide_ele]*len(init_list), segfunc_sum, ide_ele)",
            "",
            "    def add(self, x):",
            "        ind = self.index_list[x].pop()",
            "        self.used_index_list[x].append(ind)",
            "",
            "        self.kosu.update(ind, 1)",
            "        self.sum.update(ind, x)",
            "",
            "    def delete(self, x):",
            "        ind = self.used_index_list[x].pop()",
            "        self.index_list[x].append(ind)",
            "",
            "        self.kosu.update(ind, 0)",
            "        self.sum.update(ind, 0)",
            "",
            "    def kth_func(self, k):",
            "        ind, _ = self.kosu.ge(k)",
            "        if ind is None:",
            "            return ind",
            "        return self.sum.query(0,ind+1)",
            "",
            "",
            "# A:先読みしたセグ木に突っ込みたいものリスト全部",
            "# Aをsortして入れると小さい順からindexが作成されて小さいほうからK個の和などが求められるよ",
            "bak = BAKEMONO(A)",
        ],
        "description": ""
    },
    "NIBUGRAPH_KENSYUTU": {
        "prefix": "NIBUGRAPH_KENSYUTU",
        "body": [
            "# Nノード数 ",
            "uf = UnionFind(N*2) # 最初のNを赤、i+Nを青とする",
            "maps = {i:[] for i in range(NODE)}",
            "for i in range(LOOP_NUM):",
            "    a,b = mi()",
            "    uf.union(a-1+N, b-1) # 青から赤へ",
            "    uf.union(a-1, b-1+N) # 赤から青へ",
            "",
            "# 自分の赤と青が同じなら矛盾 → 二部グラフではない",
            "for i in range(N):",
            "    if uf.same(i,i+N):",
            "        print(\"a\",(i,i+N))",
        ],
        "description": ""
    },
    "SparseTable": {
        "prefix": "SparseTable",
        "body": [
            "#####segfunc#####",
            "def tablefunc(x, y):",
            "    return min(x,y)",
            "#################",
            "",
            "#####ide_ele#####",
            "ide_ele = float(\"inf\")",
            "#################",
            "",
            "class SparseTable:",
            "    def __init__(self, A, tablefunc, ide_ele):",
            "        N = len(A)",
            "        bit = (N-1).bit_length()",
            "        self.dp = [[ide_ele] * (bit+1) for _ in range(N)]",
            "        # 各要素に値を入れる",
            "        for i in range(N):",
            "            self.dp[i][0] = A[i]",
            "",
            "        b = 1",
            "        for i in range(1, bit):",
            "            for j in range(N-1):",
            "                self.dp[j][i] = tablefunc(self.dp[j][i-1], self.dp[min(j+b, N-1)][i-1])",
            "            self.dp[j-1][i] = self.dp[j-1][i-1]",
            "            b<<=1",
            "",
            "    # l:閉区間",
            "    # r:開区間",
            "    def query(self, l,r):",
            "        length = r-l",
            "        k = (length - 1).bit_length()-1 # 幅がrを超えない範囲で作る(-1することで余裕を持たせている)",
            "        if k<0:",
            "            return self.dp[l][0]",
            "        # 2の冪で幅を伸ばしているのでlとrの幅が半分を超えることはあり得ない(はず)",
            "        # rからもkこ左に伸長して考えると覆えるはず",
            "        k2 = 1 << k",
            "        ",
            "        return tablefunc(self.dp[l][k] , self.dp[r-k2][k])",
            "",
            "sp = SparseTable(A, tablefunc, ide_ele)",
        ],
        "description": ""
    },
    "KINBOU": {
        "prefix": "KINBOU",
        "body": [
            "# 4近傍",
            "d = [(0,1), (0,-1), (1,0), (-1, 0)]",
            "",
            "# 8近傍",
            "d = [(0,1), (0,-1), (1,0), (-1, 0), (1,1), (1,-1), (-1,-1), (-1, 1)]",
        ],
        "description": ""
    },
    "ENSYU_KOUSA": {
        "prefix": "ENSYU_KOUSA",
        "body": [
            "def circle_collision(x1, y1, r1, x2, y2, r2): ",
            "    # 二つの円の中心座標と半径があること",
            "    # x1, y1, r1",
            "    # x2, y2, r2",
            "    d_2 = ((x1-x2)**2 + (y1-y2)**2)",
            "    if (d_2 > (r1+r2)**2) or (d_2 < (r1-r2)**2):",
            "        # 円周は交差してません",
            "        # print(c1,c2, d_2, r1,r2)",
            "        return False",
            "    else:",
            "        # 円周交差",
            "        return True",
        ],
        "description": ""
    },
    "EIZOKU_LIST": {
        "prefix": "EIZOKU_LIST",
        "body": [
            "class PersistentList:",
            "    def __init__(self, A=None):",
            "        if A is not None:",
            "            # 構築",
            "            out = []",
            "            temp1 = []",
            "            N = len(A)",
            "            length = N.bit_length()",
            "            for i in range(2**(length)):",
            "                if len(A) > i: temp1.append(A[i])",
            "                else: temp1.append(0)",
            "",
            "            for b in range((length),0, -1):",
            "                temp = [[temp1[i], temp1[i+1]] for i in range(0, 2**b, 2)]",
            "                temp1 = temp",
            "",
            "            self.lists = temp1[0]",
            "            self.height = length",
            "            self.h_num = 1 << (length-1)",
            "",
            "    def update(self, index, value):",
            "        kari = self.h_num",
            "        next_ver = []",
            "        now = next_ver",
            "        pointer = now.append",
            "        prev_ver = self.lists",
            "",
            "        for i in range(self.height):",
            "            # 上からbitの0/1で分けてく",
            "            if index & kari: # 1の時",
            "                if i != self.height-1:",
            "                    pointer(prev_ver[0]); pointer([])",
            "                    now  = now[1]",
            "                    prev_ver = prev_ver[1]",
            "                else:",
            "                    pointer(prev_ver[0]); pointer(value)",
            "                ",
            "            else:",
            "                if i != self.height-1:",
            "                    pointer([]); pointer(prev_ver[1])",
            "                    now  = now[0]",
            "                    prev_ver = prev_ver[0]",
            "                else:",
            "                    pointer(value); pointer(prev_ver[1])",
            "",
            "            pointer = now.append",
            "            kari >>= 1",
            "",
            "        # 新規永続配列を作成し次のverとして返す",
            "        new = self._copy()",
            "        new.lists = next_ver",
            "        return new",
            "",
            "",
            "    def get(self, index):",
            "        kari = self.h_num",
            "        ver_lists = root = self.lists",
            "",
            "        for i in range(self.height-1):",
            "            # 上からbitの0/1で分けてく",
            "            if index & kari: # 1の時",
            "                ver_lists = ver_lists[1]",
            "            else:",
            "                ver_lists = ver_lists[0]",
            "            kari >>= 1",
            "        ",
            "        num = ver_lists[index & kari]",
            "        return num",
            "",
            "    def _copy(self):",
            "        new = PersistentList()",
            "        new.height = self.height",
            "        new.h_num = self.h_num",
            "        return new",
            "",
            "",
        ],
        "description": ""
    },

    "EIZOKU_Stack": {
        "prefix": "EIZOKU_Stack",
        "body": [
            "class PersistentStack:",
            "    def __init__(self, A=None):",
            "        self.lists = PersistentList(A)",
            "        self.l = 0",
            "        self.r = 0",
            "",
            "    def popleft(self):",
            "        deq_len = self.r - self.l",
            "        if deq_len <= 0: # rの方が大きければOK　r-lが配列長",
            "            return (None, None)",
            "",
            "        new = self.copy()",
            "        num = self.lists.get(index=self.l)",
            "        new.l += 1",
            "        new.lists = self.lists",
            "        return num, new",
            "",
            "    # dequeにするときに使う、len(A)*2に拡張してlとrの初期値をlen(A)にしたい",
            "    def pop(self):",
            "        deq_len = self.r - self.l",
            "        if deq_len <= 0: # rの方が大きければOK　r-lが配列長",
            "            return (None, None)",
            "    ",
            "        new = self.copy()",
            "        num = self.lists.get(index=self.r-1)",
            "        new.r -= 1",
            "        new.lists = self.lists",
            "        return num, new",
            "    ",
            "    def push(self, v):",
            "        deq_len = self.r - self.l",
            "        if deq_len < 0: # rの方が大きければOK　r-lが配列長",
            "            return None",
            "    ",
            "        new = self.copy()",
            "        new.lists = self.lists.update(index=self.r, value=v)",
            "        new.r += 1",
            "        return new",
            "",
            "",
            "    # def pushleft(self, v):",
            "    #     deq_len = self.r - self.l",
            "    #     if deq_len < 0: # rの方が大きければOK　r-lが配列長",
            "    #         return (None, None)",
            "",
            "    #     new = self.copy()",
            "    #     new.l -= 1",
            "    #     new.lists = self.lists.update(index=self.l, value=v)",
            "    #     return new",
            "",
            "    def copy(self):",
            "        new = PersistentStack()",
            "        new.l = self.l",
            "        new.r = self.r",
            "        return new",
            "",
            "   ",
        ],
        "description": ""
    },
    "WaveletMatrix": {
        "prefix": "WaveletMatrix",
        "body": [
            "import bisect",
            "import itertools as it",
            "import heapq",
            "from collections import deque",
            "",
            "class WaveletMatrix:",
            "",
            "    def __init__(self, A, n=30):",
            "        # matrix構築",
            "        self.bit_length = n",
            "        self.matrix = [[0]*(len(A)+1) for _ in range(self.bit_length)]# 元の並び順での各数値各桁のbit",
            "        self.matrix_zero = [[0]*(len(A)+1) for _ in range(self.bit_length)]# 元の並び順での各数値各桁のbit",
            "        self.zero_count = [len(A)] * self.bit_length # 各bit桁のゼロの数",
            "        self.start_dict = {}",
            "        self.count_dict = {}",
            "",
            "",
            "        kari = 1<<(self.bit_length-1)",
            "        zero = []",
            "        one = []",
            "        # 各桁ごとにbitが0 or 1で並び替え(0同士、1同士の順序は維持)",
            "        for x, a in enumerate(A, start=1):",
            "            if a&kari:",
            "                one.append((x,a))",
            "                self.zero_count[0]-=1",
            "                self.matrix[0][x]=1",
            "            else:",
            "                self.matrix_zero[0][x]=1",
            "                zero.append((x,a))",
            "            if a in self.count_dict:",
            "                self.count_dict[a] += 1",
            "            else:",
            "                self.count_dict[a] = 1",
            "",
            "        kari >>=1",
            "        for y in range(1, self.bit_length):",
            "            temp_zero = []",
            "            temp_one = []",
            "            c=1",
            "            for x, a in zero:",
            "                if a&kari:",
            "                    temp_one.append((x,a))",
            "                    self.zero_count[y]-=1",
            "                    self.matrix[y][c]=1",
            "                else:",
            "                    self.matrix_zero[y][c]=1",
            "                    temp_zero.append((x,a))",
            "                c+=1",
            "",
            "            for x, a in one:",
            "                if a&kari:",
            "                    temp_one.append((x,a))",
            "                    self.zero_count[y]-=1",
            "                    self.matrix[y][c]=1",
            "                else:",
            "                    self.matrix_zero[y][c]=1",
            "                    temp_zero.append((x,a))",
            "                c+=1",
            "",
            "            zero = temp_zero[:]",
            "            one = temp_one[:]",
            "            kari >>=1",
            "",
            "        # 基数ソート後の並び順を取得",
            "        c = 0",
            "        for x,a in zero:",
            "            if a not in self.start_dict:",
            "                self.start_dict[a] = c",
            "            c+=1",
            "        for x,a in one:",
            "            if a not in self.start_dict:",
            "                self.start_dict[a] = c",
            "            c+=1",
            "",
            "        # # 累積",
            "        for i in range(self.bit_length):",
            "            self.matrix[i] = list(it.accumulate(self.matrix[i]))",
            "            self.matrix_zero[i] = list(it.accumulate(self.matrix_zero[i]))",
            "",
            "",
            "    # indexは終端(半開区間)",
            "    # 先頭からindex(開区間)までにvalueが何個あるかを取得",
            "    def rank(self, index, value):",
            "        if value not in self.start_dict: # 最初に与えられたAに存在しないときは0を返す",
            "            return None",
            "        # rank",
            "        kari = 1<<(self.bit_length-1)",
            "        for i in range(self.bit_length):",
            "            if value&kari: # 検索する値の指定のbitが1なら",
            "                index = self.zero_count[i] + (self.matrix[i][index])",
            "            else:",
            "                index = index - self.matrix[i][index]",
            "",
            "            kari >>=1",
            "        return (index - self.start_dict[value])",
            "",
            "        # rankテストコード",
            "        # from collections import defaultdict",
            "        # WM = WaveletMatrix(A)",
            "",
            "        # dicts = defaultdict(int)",
            "        # for i,a in enumerate(A, start=1):",
            "        #     dicts[a] += 1",
            "        #     for k, v in dicts.items():",
            "        #         if WM.rank(index=i, value=k) != v:",
            "        #             print(dicts, k, v, WM.rank(index=i, value=k))",
            "        #             print(\"not same\")",
            "",
            "    ",
            "    # indexは終端(半開区間)",
            "    # num個目のvalueがどのindexにあったかを取得",
            "    # ナイーブにやるなら値をキーとした配列にindex入れてそれで取る",
            "    def select(self, value, num):",
            "        if value not in self.start_dict: # 最初に与えられたAに存在しないときは0を返す",
            "            return None",
            "",
            "        if self.count_dict[value] < num: # 元の配列に存在してる数を超えた場合",
            "            return None",
            "",
            "        index = self.start_dict[value] + num # start_dictは0",
            "        kari = 1",
            "        for i in range(self.bit_length-1, -1, -1):",
            "            if value&kari: # 検索する値の指定のbitが1なら",
            "                one_num = index -self.zero_count[i]",
            "                index = bisect.bisect_left(self.matrix[i], one_num)",
            "",
            "            else:",
            "                index = bisect.bisect_left(self.matrix_zero[i], index)",
            "            kari <<=1",
            "        return index",
            "",
            "        # import random ",
            "        # from collections import defaultdict",
            "        # from collections import Counter",
            "        # A = [random.randint(10, 10**9) for _ in range(2*10**5)]",
            "        # WM = WaveletMatrix(A)",
            "        # Co = Counter(A)",
            "        # dicts = defaultdict(int)",
            "        # count = 1",
            "",
            "        # for k,v in Co.items():",
            "        #     for vv in range(1,v+1):",
            "        #         i = WM.select(value=k, num=vv)",
            "        #         if A[i-1] != k:",
            "        #             print(\"not same\")",
            "        #             break",
            "",
            "        # zeroの数の累積和を持っているがこれを1の累積和の行列で代替したい",
            "",
            "",
            "    # lからrの中でk番目に小さい値",
            "    def quantile(self, l, r, k):",
            "        out = 0",
            "        if (r-l) < k or k<=0:",
            "            return (None, None)",
            "",
            "        # print(zero_num, one_num)",
            "        for i in range(self.bit_length):",
            "            out <<= 1",
            "            # rは開区間, lは閉区間",
            "            zero_num = self.matrix_zero[i][r] - self.matrix_zero[i][l]",
            "            one_num = self.matrix[i][r] - self.matrix[i][l]",
            "",
            "            if zero_num < k <= zero_num+one_num: # bitが1なら",
            "                out += 1",
            "                l = self.zero_count[i] + (self.matrix[i][l])",
            "                r = self.zero_count[i] + (self.matrix[i][r])",
            "                k -= zero_num",
            "",
            "            else:",
            "                l = l - self.matrix[i][l]",
            "                r = r - self.matrix[i][r]",
            "",
            "            # print(out,k)",
            "            # print(f\"l:{l}, r:{r}, zero_num:{zero_num}, one_num:{one_num}\")",
            "",
            "        # out:K番目に小さい値",
            "        # num:何個目のoutか (selectでindexを取ってくる時に使う)",
            "        num = l-self.start_dict[out] + k",
            "        return out, num",
            "",
            "        # #テストコード",
            "        # from random import randint",
            "        # N = 10**3",
            "        # A = [randint(1,100) for _ in range(N)]",
            "        # WM = WaveletMatrix(A)",
            "",
            "        # for i in range(100):",
            "        #     l = randint(0,N-1)",
            "        #     r = randint(l+1,N)",
            "        #     k = randint(1, r-l)",
            "        #     B = sorted(A[l:r])",
            "        #     if B[k-1] != WM.quantile(l,r,k)[0]:",
            "        #         print(\"not same\")",
            "        #         break",
            "",
            "    # lからrの中で出現頻度の多い数値を上位k個取り出す、種類が足りない場合は途中で打ち切る",
            "    def topk(self, org_l, org_r, k):",
            "        q1 = [((org_r-org_l), org_l, 0)]",
            "",
            "        for i in range(self.bit_length):",
            "            q2 = []",
            "            while q1:",
            "                haba, l, num = q1.pop()",
            "                r = haba + l",
            "                num <<= 1",
            "                # rは開区間, lは閉区間",
            "                zero_num = self.matrix_zero[i][r] - self.matrix_zero[i][l]",
            "                one_num = self.matrix[i][r] - self.matrix[i][l]",
            "                if zero_num != 0:",
            "                    r1 = self.matrix_zero[i][r]",
            "                    l1 = self.matrix_zero[i][l]",
            "                    if i == (self.bit_length-1):",
            "                        heapq.heappush(q2, (-1*(r1-l1), num))",
            "                    else:",
            "                        q2.append((r1-l1, l1, num))",
            "",
            "                if one_num != 0:",
            "                    r2 = self.zero_count[i] + self.matrix[i][r]",
            "                    l2 = self.zero_count[i] + self.matrix[i][l]",
            "                    if i == (self.bit_length-1):",
            "                        heapq.heappush(q2, (-1*(r2-l2), num+1))",
            "                    else:",
            "                        q2.append((r2-l2, l2, num+1))",
            "            q1 = q2",
            "        out = []",
            "        c = 0",
            "        ",
            "        while q1:",
            "            if k<=0:",
            "                break",
            "            haba, num = heapq.heappop(q1)",
            "            out.append((num, haba*-1))",
            "            k -= 1",
            "        # while q1:",
            "        #     haba, num = heapq.heappop(q1)",
            "        #     out.append((num, min(haba*-1, k)))",
            "        #     if haba*-1 >= k: ",
            "        #         break",
            "        #     else:",
            "        #         k += haba",
            "        return out",
            "",
            "        #テストコード",
            "        # from random import randint",
            "        # from collections import Counter",
            "        # for _ in range(100):",
            "        #     N = 10**3",
            "        #     A = [randint(1,100) for _ in range(N)]",
            "        #     WM = WaveletMatrix(A)",
            "",
            "        #     for i in range(100):",
            "        #         l = randint(0,N-1)",
            "        #         r = randint(l+1,N)",
            "        #         k = randint(1, r-l)",
            "        #         C = Counter(A[l:r])",
            "        #         B = sorted([(v,-1*kk) for kk, v in C.most_common()], reverse=True)",
            "        #         C = [v[1]*-1 for v in B]",
            "        #         out = WM.topk(l,r,k)",
            "        #         oo = [o[0] for o in out]",
            "",
            "        #         flg = False",
            "        #         for b,o in zip(C[:k], oo):",
            "        #             if b != o:",
            "        #                 flg = True",
            "        #                 break",
            "        #         if flg:",
            "        #             print(\"Not same\")    ",
            "        #             break",
        ],
        "description": ""
    },



}
