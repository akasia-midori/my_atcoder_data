# 左傾赤黒木(Left Leaning Red Black Trees)のページ

## 概要
通常の赤黒木は以下の制約がある
・各ノードは赤か黒のどれかで塗られている
・赤と赤は親子にはならない
・全ての葉に到達するのに通る黒ノードの数は同じ
・根は必ず黒

ここに「赤ノードは左にしか付かない」制約を付与したもの。  
正確には  
・requiring that 3-nodes always lean to the left (and that 4-nodes are balanced)  

balancedが何を表してるかは知らないけど元論文では4ノード(左右に赤ノードが付いた状態)の時に左右の子ノードと自分の色を反転させてたので多分これのことを言ってるっぽい  

赤黒木は2-3-4木を2分木でシミュレーションした結果出てきた物なのだが、2-3-4木でいうところの子ノードが3つの状態の時に2つある親ノードのどちらが更に親になるかでパターンが存在していた。  
これを消すことで赤ノードの子に赤ノードが付いた時の回転パターンを減らすのが狙い。  
子ノードが4つの時に親ノードの真ん中のノードを更に親(祖父母)にすることで回転パターンを更に減らしている。(たぶんこれをしないと「右側にinsertが発生した時」に子ノードが3つある状態で削減していたパターンが発生してしまう)  


|  処理  |  計算量  |
| ---- | ---- |
|  追加  | O(logN)  |
|  削除  | O(logN)  |
|  検索  | O(logN)  |
|  二分探索  | O(logN) |

<br></br>

## 用途
AVL木と一緒

<br></br>

## 処理概要

### 追加 
根のノードから以下を行う。
追加したい値をVとする。  

1. 自分のノードに含まれる値 <= Vなら左のノードへ遷移する。もし、遷移先が無ければそこに新しいノードを追加する。  
2. そうでなければ右のノードへ遷移する。もし、遷移先が無ければそこに新しいノードを追加する。  

追加のロジックは普通の二分木と同じ。  
追加したノードを含む木の高さを反映させ、バランスが崩れていないかを判定する。崩れていた場合、木の回転を行いバランス調整を行う。


<br></br>

### 削除 
根のノードから以下を行う。
削除したい値をVとする。  

削除したい値が見つかるまで以下を行う.もし見つからなかったら終わり。アルゴリズムからの要望はないので好きな処理にしてね。
1. 自分のノードに含まれる値 <= Vなら左のノードへ遷移する。もし、遷移先が無ければそこで終わり。  
2. そうでなければ右のノードへ遷移する。もし、遷移先が無ければそこで終わり。  
3. 削除したい場所に辿り着いたら以下の分岐に入る。　 
4. 回転してバランスを整える


気力が尽きた



